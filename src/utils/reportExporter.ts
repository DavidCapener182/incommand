/**
 * Report Exporter
 * Export analytics and incident reports to PDF, CSV, and Excel formats
 */

interface ExportData {
  title: string
  headers: string[]
  rows: any[][]
  metadata?: {
    event?: string
    dateRange?: string
    generatedBy?: string
    generatedAt?: string
  }
}

interface ExportOptions {
  filename?: string
  includeMetadata?: boolean
  orientation?: 'portrait' | 'landscape'
}

class ReportExporter {
  /**
   * Export to CSV
   */
  exportToCSV(data: ExportData, options: ExportOptions = {}): void {
    const { filename = 'report.csv', includeMetadata = true } = options
    
    let csvContent = ''

    // Add metadata
    if (includeMetadata && data.metadata) {
      csvContent += `"${data.title}"\n`
      if (data.metadata.event) csvContent += `"Event: ${data.metadata.event}"\n`
      if (data.metadata.dateRange) csvContent += `"Date Range: ${data.metadata.dateRange}"\n`
      if (data.metadata.generatedBy) csvContent += `"Generated By: ${data.metadata.generatedBy}"\n`
      if (data.metadata.generatedAt) csvContent += `"Generated At: ${data.metadata.generatedAt}"\n`
      csvContent += '\n'
    }

    // Add headers
    csvContent += data.headers.map(h => `"${h}"`).join(',') + '\n'

    // Add rows
    data.rows.forEach(row => {
      csvContent += row.map(cell => {
        // Escape quotes and wrap in quotes
        const cellStr = String(cell || '')
        return `"${cellStr.replace(/"/g, '""')}"`
      }).join(',') + '\n'
    })

    this.downloadFile(csvContent, filename, 'text/csv')
  }

  /**
   * Export to Excel (XLSX format using CSV with BOM)
   */
  exportToExcel(data: ExportData, options: ExportOptions = {}): void {
    const { filename = 'report.xlsx' } = options
    
    // For now, export as CSV with Excel-compatible format
    // In production, you'd want to use a library like xlsx or exceljs
    const csvContent = this.generateCSVContent(data, options)
    
    // Add BOM for Excel UTF-8 support
    const BOM = '\uFEFF'
    this.downloadFile(BOM + csvContent, filename.replace('.xlsx', '.csv'), 'text/csv')
  }

  /**
   * Export to PDF
   */
  async exportToPDF(data: ExportData, options: ExportOptions = {}): Promise<void> {
    const { 
      filename = 'report.pdf', 
      includeMetadata = true,
      orientation = 'portrait'
    } = options

    // Create HTML content for PDF
    const htmlContent = this.generateHTMLReport(data, includeMetadata)

    // Use browser's print functionality for PDF
    // In production, you'd want to use a library like jsPDF or pdfmake
    const printWindow = window.open('', '_blank')
    if (!printWindow) {
      throw new Error('Unable to open print window. Please allow popups.')
    }

    printWindow.document.write(htmlContent)
    printWindow.document.close()

    // Wait for content to load
    await new Promise(resolve => setTimeout(resolve, 500))

    // Trigger print dialog
    printWindow.print()
    
    // Note: User will need to "Save as PDF" from print dialog
  }

  /**
   * Generate CSV content
   */
  private generateCSVContent(data: ExportData, options: ExportOptions): string {
    const { includeMetadata = true } = options
    let csvContent = ''

    // Add metadata
    if (includeMetadata && data.metadata) {
      csvContent += `"${data.title}"\n`
      Object.entries(data.metadata).forEach(([key, value]) => {
        if (value) csvContent += `"${this.formatKey(key)}: ${value}"\n`
      })
      csvContent += '\n'
    }

    // Add headers
    csvContent += data.headers.map(h => `"${h}"`).join(',') + '\n'

    // Add rows
    data.rows.forEach(row => {
      csvContent += row.map(cell => {
        const cellStr = String(cell || '')
        return `"${cellStr.replace(/"/g, '""')}"`
      }).join(',') + '\n'
    })

    return csvContent
  }

  /**
   * Generate HTML report for PDF
   */
  private generateHTMLReport(data: ExportData, includeMetadata: boolean): string {
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>${data.title}</title>
        <style>
          @page { size: auto; margin: 20mm; }
          body { 
            font-family: Arial, sans-serif; 
            padding: 20px;
            color: #333;
          }
          h1 { 
            color: #2563eb; 
            border-bottom: 3px solid #2563eb;
            padding-bottom: 10px;
            margin-bottom: 20px;
          }
          .metadata { 
            background: #f3f4f6;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
          }
          .metadata p { 
            margin: 5px 0;
            color: #6b7280;
          }
          table { 
            width: 100%; 
            border-collapse: collapse;
            margin-top: 20px;
          }
          th { 
            background: #2563eb;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
          }
          td { 
            padding: 10px;
            border-bottom: 1px solid #e5e7eb;
          }
          tr:nth-child(even) { 
            background: #f9fafb;
          }
          tr:hover {
            background: #f3f4f6;
          }
          .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e5e7eb;
            text-align: center;
            color: #9ca3af;
            font-size: 12px;
          }
          @media print {
            body { padding: 0; }
            .no-print { display: none; }
          }
        </style>
      </head>
      <body>
        <h1>${data.title}</h1>
        
        ${includeMetadata && data.metadata ? `
          <div class="metadata">
            ${data.metadata.event ? `<p><strong>Event:</strong> ${data.metadata.event}</p>` : ''}
            ${data.metadata.dateRange ? `<p><strong>Date Range:</strong> ${data.metadata.dateRange}</p>` : ''}
            ${data.metadata.generatedBy ? `<p><strong>Generated By:</strong> ${data.metadata.generatedBy}</p>` : ''}
            ${data.metadata.generatedAt ? `<p><strong>Generated At:</strong> ${data.metadata.generatedAt}</p>` : ''}
          </div>
        ` : ''}

        <table>
          <thead>
            <tr>
              ${data.headers.map(h => `<th>${h}</th>`).join('')}
            </tr>
          </thead>
          <tbody>
            ${data.rows.map(row => `
              <tr>
                ${row.map(cell => `<td>${cell || ''}</td>`).join('')}
              </tr>
            `).join('')}
          </tbody>
        </table>

        <div class="footer">
          <p>Generated by inCommand Event Management System</p>
          <p>${new Date().toLocaleString()}</p>
        </div>
      </body>
      </html>
    `
  }

  /**
   * Download file
   */
  private downloadFile(content: string, filename: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
  }

  /**
   * Format metadata key
   */
  private formatKey(key: string): string {
    return key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())
  }
}

// Create singleton instance
export const reportExporter = new ReportExporter()

// Convenience functions
export const exportReportToCSV = (data: ExportData, options?: ExportOptions) => {
  reportExporter.exportToCSV(data, options)
}

export const exportReportToExcel = (data: ExportData, options?: ExportOptions) => {
  reportExporter.exportToExcel(data, options)
}

export const exportReportToPDF = (data: ExportData, options?: ExportOptions) => {
  return reportExporter.exportToPDF(data, options)
}

// React hook for exporting
export function useReportExporter() {
  return {
    exportToCSV: reportExporter.exportToCSV.bind(reportExporter),
    exportToExcel: reportExporter.exportToExcel.bind(reportExporter),
    exportToPDF: reportExporter.exportToPDF.bind(reportExporter)
  }
}

// Helper to format incident data for export
export function formatIncidentsForExport(incidents: any[], eventName?: string): ExportData {
  return {
    title: 'Incident Report',
    headers: [
      'ID',
      'Type',
      'Status',
      'Priority',
      'Location',
      'Occurrence',
      'Created At',
      'From',
      'To'
    ],
    rows: incidents.map(incident => [
      incident.id || 'N/A',
      incident.incident_type || 'N/A',
      incident.status || 'Open',
      incident.priority || 'Medium',
      incident.location || 'N/A',
      incident.occurrence || 'N/A',
      new Date(incident.created_at).toLocaleString(),
      incident.callsign_from || 'N/A',
      incident.callsign_to || 'N/A'
    ]),
    metadata: {
      event: eventName,
      dateRange: 'All time',
      generatedBy: 'System',
      generatedAt: new Date().toLocaleString()
    }
  }
}

// Helper to format analytics data for export
export function formatAnalyticsForExport(analytics: any, eventName?: string): ExportData {
  return {
    title: 'Analytics Report',
    headers: ['Metric', 'Value', 'Change', 'Trend'],
    rows: [
      ['Total Incidents', analytics.totalIncidents || 0, `${analytics.incidentChange || 0}%`, analytics.incidentTrend || 'Stable'],
      ['Active Incidents', analytics.activeIncidents || 0, `${analytics.activeChange || 0}%`, analytics.activeTrend || 'Stable'],
      ['Staff On Duty', analytics.staffOnDuty || 0, `${analytics.staffChange || 0}%`, analytics.staffTrend || 'Stable'],
      ['Avg Response Time', `${analytics.avgResponseTime || 0} min`, `${analytics.responseChange || 0}%`, analytics.responseTrend || 'Stable'],
      ['Resolution Rate', `${analytics.resolutionRate || 0}%`, `${analytics.resolutionChange || 0}%`, analytics.resolutionTrend || 'Stable']
    ],
    metadata: {
      event: eventName,
      dateRange: analytics.dateRange || 'Current Event',
      generatedBy: 'System',
      generatedAt: new Date().toLocaleString()
    }
  }
}
